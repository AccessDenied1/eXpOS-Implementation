loadi(69, 11);          // load idle code from disk to memory
loadi(70, 12);

loadi(16, 29);          // load int 7 code from disk to memory
loadi(17, 30);

loadi(4, 17);           // load timer interrupt routine from disk to memory
loadi(5, 18);

loadi(63, 13);          // load shared library from disk to memory
loadi(64, 14);

loadi(65, 7);           // load init from disk to memory
loadi(66, 8);

loadi(22, 35);          // load int 10 from disk to memory
loadi(23, 36);

loadi(2, 15);           // load exception handler from disk to memory
loadi(3, 16);


// Set up Process Table

// process 0
[PROCESS_TABLE + 1] = 0;                            // process id
[PROCESS_TABLE + 4] = CREATED;                      // state of process
[PROCESS_TABLE + 11] = 82;                          // user page area
[PROCESS_TABLE + 13] = 8 * 512;                     // UPTR value
[PROCESS_TABLE + 12] = 0;                           // KPTR value
[PROCESS_TABLE + 14] = PAGE_TABLE_BASE;             // PTBR value
[PROCESS_TABLE + 15] = 10;                          // PTLR value

// process 1
[PROCESS_TABLE + 16 + 1] = 1;                       // process id
[PROCESS_TABLE + 16 + 4] = RUNNING;                 // state
[PROCESS_TABLE + 16 + 11] = 80;                     // user page area
[PROCESS_TABLE + 16 + 13] = 8 * 512;                // UPTR value
[PROCESS_TABLE + 16 + 12] = 0;                      // KPTR value
[PROCESS_TABLE + 16 + 14] = PAGE_TABLE_BASE + 20;   // PTBR value
[PROCESS_TABLE + 16 + 15] = 10;                     // PTLR value

PTBR = PAGE_TABLE_BASE;                 // Setting up the page table registers
PTLR = 10;

// Setting up the page table for proc 0

[PTBR + 0] = -1;                        // Shared Library
[PTBR + 1] = "0000";
[PTBR + 2] = -1;
[PTBR + 3] = "0000";

[PTBR + 4] = -1;                        // Heap
[PTBR + 5] = "0000";
[PTBR + 6] = -1;
[PTBR + 7] = "0000";

[PTBR + 8] = 69;                        // Code
[PTBR + 9] = "0100";
[PTBR + 10] = 70;
[PTBR + 11] = "0100";
[PTBR + 12] = -1;
[PTBR + 13] = "0000";
[PTBR + 14] = -1;
[PTBR + 15] = "0000";

[PTBR + 16] = 81;                       // Stack
[PTBR + 17] = "0110";
[PTBR + 18] = -1;
[PTBR + 19] = "0000";

[81*512] = [69 * 512 + 1];              // Entry point IP value stored at the top of stack

// Setting up the page table for proc 1

PTBR = PAGE_TABLE_BASE + 20;            // setting PTBR value for init

[PTBR + 0] = 63;                        // Shared Library
[PTBR + 1] = "0100";
[PTBR + 2] = 64;
[PTBR + 3] = "0100";

[PTBR + 4] = 78;                        // Heap
[PTBR + 5] = "0110";
[PTBR + 6] = 79;
[PTBR + 7] = "0110";

[PTBR + 8] = 65;                        // Code
[PTBR + 9] = "0100";
[PTBR + 10] = 66;
[PTBR + 11] = "0100";
[PTBR + 12] = -1;
[PTBR + 13] = "0000";
[PTBR + 14] = -1;
[PTBR + 15] = "0000";

[PTBR + 16] = 76;                       // Stack
[PTBR + 17] = "0110";
[PTBR + 18] = 77;
[PTBR + 19] = "0110";

[76*512] = [65 * 512 + 1];              // Entry point IP value stored at the top of stack
SP = 8*512;                             // stack is given logical address

[SYSTEM_STATUS_TABLE + 1] = 1;          // pid of currently running process

ireturn;